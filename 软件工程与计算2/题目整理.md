[TOC]

# 名词解释

## 软件工程

1. 应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。
2. 对 1）各种方法的研究。

## 需求

1. 用户为了解决问题或达到某些目标所需要的条件或能力；
2. 系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；
3. 对 1 或 2 中的一个条件或一种能力的一种文档化表述。

## 软件设计

1. 软件设计是指关于软件对象的设计，是一种设计活动。软件设计既指软件对象实现的规格说明，又指这个规格说明产生的过程。
2. 软件设计活动以需求开发的制品（需求规格说明和分析模型）为基础，构建软件设计方案描述和原型，为后期的构造活动提供规划或蓝图。
3. 软件设计兼具工程性和艺术性，由于软件系统的可变性，软件设计具有演化性，也因为软件设计的过程实际上就是一系列决策发生的过程，软件设计具有决策性。

## 可用性

可用性不是用户界面的单一一维属性，它包含以下维度。

1. 易学性：新手用户容易学习，能够很快使用系统。
2. 效率：熟练的用户可以高效使用它
3. 易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。（超市可以缓存之前的信息）
4. 出错率：几乎没有错误，可以从错误中快速恢复
5. 主观满意度：让用户有良好的体验。

## 耦合和内聚

1. 内聚：表达的是一个模块内部的联系的紧密性：包括信息内聚、功能内聚、通信内聚、过程内聚、时间内聚、逻辑内聚和偶然内聚。
2. 耦合：描述的是两个模块之间关系的复杂程度：包括内容耦合，公共耦合，重复耦合，控制耦合，印记耦合，数据耦合

## 重构、测试驱动开发、结对编程

它们是软件构造的实践方法。

1. 重构：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构。
2. 测试驱动开发：测试驱动开发要求程序员在编写一段代码之前，优先完成该段代码的测试代码。并在编程中重复执行测试代码，以验证程序的正确性。
3. 结对编程：两个程序员挨着坐在一起，共同协作进行软件构造活动。一个是驾驶员，一个是观察者，观察者会对驾驶员输入的代码进行评审，并提出意见。

# 需求分析

需求的三个层次：

1. 业务需求：是高层次的解决方案和系统特性、系统开发的战略出发点、高层次的需求，描述为什么要开发系统。
2. 用户需求：执行具体任务的用户对系统所能完成任务的期望，描述了系统能帮用户做什么（直接用户、间接用户）
3. 系统级需求：需求分析模型：用户对系统行为的期望，每个系统级需求反映了一次外界与系统的交互行为，或者系统的一个实现细节（和用户需求有着很大的区别）

需求类型：

- 项目需求
- 过程需求
- 系统需求
  - 其他需求
  - 硬件需求
  - 软件需求
    - 功能需求
    - 数据需求
    - 性能需求
    - 质量属性
    - 对外接口
    - 约束

如果遇到：判断xx需求属于哪种类型，运用朴素的软件工程思想，看名字选择你的需求。这些需求的详细定义太过繁琐，如果想要了解，可以自行查阅。

> 需求可以分为项目需求，过程需求，系统需求，不切实际的需求。项目需求是针对项目的期望，例如“项目的成本要在60万人民币以下”，过程需求针对开发过程中的期望，例如“开发过程中，开发者需要提交软件需求规格说明文档。”
>
> 不切实际的需求就是不能实现的需求。包括技术不可实现（系统需要能预测未来某位用户购买的商品），资源不可实现（购买系统能够分析我们公司的财务信息），超出软件行为范围（该购买系统可以让收银员认真工作）。
>
> 系统需求包括：软件需求，硬件需求，其他需求。硬件需求就是和硬件相关的，例如需要使用专业服务器；和人力资源、协同需求称为其他需求，例如“系统在投入使用时，需要对用户进行一星期的集中培训。”
>
> 软件需求包括：
>
> 1. 功能需求：和系统主要共作相关的需求，即在不考虑物理约束的情况下，用户希望系统所能够执行的活动，这些活动可以帮助用户完成任务。“系统应该有xx功能”
> 2. 数据需求：对于系统和用户交互时，应该交互的数据类型。
> 3. 性能需求：系统整体或系统组成部分应该拥有的性能特征，例如 CPU 使用率、内存使用率等。“在处理xx时，响应速度应为xx”
> 4. 质量属性：系统应该满足的可靠性、可用性、安全性、可维护性、可移植性、易用性等维度的需求。“如果网络障碍，系统不能崩溃”
> 5. 对外接口：系统和环境中其他环境之间应该建立的接口，如用户界面，硬件接口，软件接口等待。接口的用途、接口的输入、输出、数据格式、命令格式、异常处理要求等等。
> 6. 约束：进行系统构造时需要遵守的约定，如编程语言，硬件设施等。“系统应该使用java编写”

# 用例图

## 绘制用例图

[6 分钟学会 UML 用例图_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1qN41177fw/?spm_id_from=333.1391.0.0&vd_source=aca7f699962e2a9689a88bb5bad4525e)

## 找用例

根据题干描述，逐步查找用例。一个基本的用例应该包括：用例名称，参与者，用例描述，前置条件，后置条件，基本流程。

# 概念类图

## 绘制概念类图

很像EER图，但是把实体的属性放在实体里，不需要单独写出联系名称，只需要连线即可。可以标注基数约束。

![ef533c950f1b9e0f63da5e4395f0ec8e](../../../../Documents/Tencent Files/1299351533/nt_qq/nt_data/Pic/2025-06/Ori/ef533c950f1b9e0f63da5e4395f0ec8e.png)

## 找出类间关系

1. 继承：表示一个类是另一个类的子类或特化，继承了父类的属性和行为。子类用空心三角箭头指向父类。
2. 依赖：表示一个类临时使用到另一个类，通常作为参数、局部变量或方法中调用。A临时使用B，A用虚线三角箭头指向被依赖的B。依赖关系是最弱的关系，最少见。
3. 关联：表示两个类之间有语义上的连接关系，是最常见的联系。两个类用实线连在一起。
4. 聚合：表示整体与部分之间的关系，部分可以脱离整体独立存在（整体可以没有部分，部分也可以不依赖于整体）。部分用空心菱形指向整体。
5. 组合：表示整体与部分之间的关系，部分不能脱离整体独立存在。部分用一个实心菱形指向整体。

# 类图

## 绘制类图

[6 分钟学会 UML 类图_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Wu4y1Y7ya/?spm_id_from=333.1391.0.0&vd_source=aca7f699962e2a9689a88bb5bad4525e)

# 物理包图

## 绘制物理包图

[UML _ 包图 - kingwzun - 博客园](https://www.cnblogs.com/kingwz/p/16685456.html)

## 写接口

根据语义写即可。要有返回值，函数名，参数。

# 顺序图

## 绘制顺序图

[5 分钟学会 UML 时序图（顺序图、序列图）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1YM411f7dr/?spm_id_from=333.1391.0.0)

![image-20250616195755423](../../../../AppData/Roaming/Typora/typora-user-images/image-20250616195755423.png)

上面那个视频可以作为对顺序图的大体了解。视频中没有讲：

1. 同步消息：调用方必须等待接收方完成操作并返回后才能继续执行的信息。实线+实箭头表示。
2. 异步消息：表示调用方不等待响应，消息发出后立即继续执行自己的逻辑。实线+虚箭头表示。
3. 返回消息：表示从被调用者返回控制权（有或没有返回值）给调用者。虚线+虚箭头表示。
4. 组合框：一个框框，里面可以框住一些消息，左上角标注opt（可选，条件满足就执行），alt（if-else），loop（循环）等等。

# 耦合和聚合

## 耦合

![image-20250616200638693](../../../../AppData/Roaming/Typora/typora-user-images/image-20250616200638693.png)

- 内容耦合强调A模块可以直接修改、影响、跳转到B模块的代码。

- 公共耦合：使用全局变量

- 重复耦合：大量重复代码。

- 控制耦合：一个模块在调用另一个模块时，需要给这个模块传递参数等信息，并且传递的信息会影响调用模块的实现结果。调用是合理的，但是调用时如果需要传递信息，并且该信息有控制性，那么就是控制耦合。

```java
// 控制耦合：ModuleA 传入 flag 控制 ModuleB 的行为
void moduleA() {
    moduleB(true); // do action1
}

void moduleB(boolean flag) {
    if(flag) {
        action1();
    } else {
        action2();
    }
}
```

- 印记耦合：一个模块在调用另一个模块的时候，调用了这个模块的全部，但是只使用了其中的一部分，称为印记耦合。

```java
class User {
    String name;
    String email;
    String password;
    int age;
}

void displayUserInfo(User user) {
    System.out.println(user.name);
}
```

- 数据耦合：数据耦合是指两个模块之间通过参数传递进行通信，且只传递必要的数据，不包含控制信息或过多的结构信息。这是模块间耦合中最理想、最松散的一种。

## 内聚

![image-20250616201549705](../../../../AppData/Roaming/Typora/typora-user-images/image-20250616201549705.png)

# 代码优缺点

## 模块化编程原则

1. 全局变量是不好的
2. 使用显式调用而不是隐式调用
3. 不要重复代码
4. 接口化编程
5. 只应调用邻居的信息，不调用邻居的邻居
6. 一个接口应该实现一个功能
7. 子类应该能替代父类，而不仅仅只有父类的一部分功能
8. 组合比继承好
9. 一个类应该只实现一类功能，而不应该很多种功能。

## 常见代码问题

- 命名
- 易读性
- 歧义
- 代码重复
- 一个函数不应过长
- 是否有校验错误

考试的时候多扯点就好了。

## 优化代码：表驱动

表驱动：将条件判断的逻辑提取为数据表（数组、映射、二维表等），通过查表的方式代替大量的 `if-else` 或 `switch-case` 语句。

# 人机交互

人机交互的五个原则是：

1. 简洁设计
2. 一致性
3. 易记性
4. 低出错率
5. 所见即所得

考试的时候多扯点就好了。

# 黑盒测试/白盒测试

## 黑盒测试

黑盒测试是将测试对象作为一个黑盒子，完全基于输入和输出数据来判断测试对象的正确性。

黑盒测试包括：等价类划分、边界值分析、决策表、状态转换。

- 等价类划分：把输入分为有效类和若干无效类（根据无效类的无效原因划分），对每个类设计一个测试样例。

- 边界值分析：对输入的每个边界值以及边界值临近节点设置测试样例

- 决策表：根据系统规则列出所有组合条件及其期望输出，适用于逻辑复杂的判断组合。

- 状态转换：当系统具有状态依赖行为时，设计状态迁移图，并测试每种状态间迁移是否正常。

   假设系统状态如下（例子简化，仅为说明）：

  - S0（初始状态）：未设置密码
  - S1：密码设置成功
  - S2：密码设置失败

  | 事件             | 当前状态 | 输入       | 下一个状态 | 输出      |
  | ---------------- | -------- | ---------- | ---------- | --------- |
  | E1: 输入有效密码 | S0       | `"abc123"` | S1         | "Valid"   |
  | E2: 输入无效密码 | S0       | `"abc"`    | S2         | "Invalid" |
  | E3: 重试成功     | S2       | `"abc123"` | S1         | "Valid"   |

## 白盒测试

白盒测试是将测试对象看做透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作。

白盒测试包括：语句覆盖，条件覆盖，路径覆盖。

- 语句覆盖：测试集需使程序中每一条语句至少执行一次。即，对于选择的每个分支，都应该至少执行一次。100%覆盖的测试集就是让每个分支都执行。
- 条件覆盖：测试集需使每个布尔表达式中的每个基本条件取到 true 和 false。即对每个选择分支，都至少执行过一次true，一次false。
- 路径覆盖：测试集需使程序中所有可能的执行路径都至少被执行一次。